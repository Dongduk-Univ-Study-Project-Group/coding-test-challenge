
### **문제 설명**

길이가 같은 두 개의 큐가 주어집니다. 하나의 큐를 골라 원소를 추출(pop)하고, 추출된 원소를 **다른 큐**에 집어넣는(insert) 작업을 통해 각 큐의 원소 합이 같도록 만들려고 합니다. 이때 필요한 작업의 최소 횟수를 구하고자 합니다. 한 번의 pop과 한 번의 insert를 합쳐서 작업을 1회 수행한 것으로 간주합니다.

큐는 먼저 집어넣은 원소가 먼저 나오는 구조입니다. 이 문제에서는 큐를 배열로 표현하며, 원소가 배열 앞쪽에 있을수록 먼저 집어넣은 원소임을 의미합니다. 즉, pop을 하면 배열의 첫 번째 원소가 추출되며, insert를 하면 배열의 끝에 원소가 추가됩니다. 예를 들어 큐 `[1, 2, 3, 4]`가 주어졌을 때, pop을 하면 맨 앞에 있는 원소 1이 추출되어 `[2, 3, 4]`가 되며, 이어서 5를 insert하면 `[2, 3, 4, 5]`가 됩니다.

다음은 두 큐를 나타내는 예시입니다.

`queue1 = [3, 2, 7, 2]
queue2 = [4, 6, 5, 1]`

두 큐에 담긴 모든 원소의 합은 30입니다. 따라서, 각 큐의 합을 15로 만들어야 합니다. 예를 들어, 다음과 같이 2가지 방법이 있습니다.

1. queue2의 4, 6, 5를 순서대로 추출하여 queue1에 추가한 뒤, queue1의 3, 2, 7, 2를 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [4, 6, 5], queue2는 [1, 3, 2, 7, 2]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 7번 수행합니다.
2. queue1에서 3을 추출하여 queue2에 추가합니다. 그리고 queue2에서 4를 추출하여 queue1에 추가합니다. 그 결과 queue1은 [2, 7, 2, 4], queue2는 [6, 5, 1, 3]가 되며, 각 큐의 원소 합은 15로 같습니다. 이 방법은 작업을 2번만 수행하며, 이보다 적은 횟수로 목표를 달성할 수 없습니다.

따라서 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수는 2입니다.

길이가 같은 두 개의 큐를 나타내는 정수 배열 `queue1`, `queue2`가 매개변수로 주어집니다. 각 큐의 원소 합을 같게 만들기 위해 필요한 작업의 최소 횟수를 return 하도록 solution 함수를 완성해주세요. 단, 어떤 방법으로도 각 큐의 원소 합을 같게 만들 수 없는 경우, -1을 return 해주세요.

---

### 제한사항

- 1 ≤ `queue1`의 길이 = `queue2`의 길이 ≤ 300,000
- 1 ≤ `queue1`의 원소, `queue2`의 원소 ≤ 10
    
    9
    
- 주의: 언어에 따라 합 계산 과정 중 산술 오버플로우 발생 가능성이 있으므로 long type 고려가 필요합니다.

---

### 입출력 예

| queue1 | queue2 | result |
| --- | --- | --- |
| [3, 2, 7, 2] | [4, 6, 5, 1] | 2 |
| [1, 2, 1, 2] | [1, 10, 1, 2] | 7 |
| [1, 1] | [1, 5] | -1 |

---

### 입출력 예 설명

**입출력 예 #1**

문제 예시와 같습니다.

**입출력 예 #2**

두 큐에 담긴 모든 원소의 합은 20입니다. 따라서, 각 큐의 합을 10으로 만들어야 합니다. queue2에서 1, 10을 순서대로 추출하여 queue1에 추가하고, queue1에서 1, 2, 1, 2와 1(queue2으로부터 받은 원소)을 순서대로 추출하여 queue2에 추가합니다. 그 결과 queue1은 [10], queue2는 [1, 2, 1, 2, 1, 2, 1]가 되며, 각 큐의 원소 합은 10으로 같습니다. 이때 작업 횟수는 7회이며, 이보다 적은 횟수로 목표를 달성하는 방법은 없습니다. 따라서 7를 return 합니다.

**입출력 예 #3**

어떤 방법을 쓰더라도 각 큐의 원소 합을 같게 만들 수 없습니다. 따라서 -1을 return 합니다.

---

### 풀이(미해결)

1. queue1에서 숫자를 하나씩 뺀다
    
    ex) [3, 2, 7, 2] → [2, 7, 2] → [7, 2] → [2] → []
    
2. queue1에 queue2 숫자를 하나씩 더한다
    
    ex) [3, 2, 7, 2, 4] → [3, 2, 7, 2, 4, 6] → [3, 2, 7, 2, 4, 6, 5] → [3, 2, 7, 2, 4, 6, 5, 1]
    
    → [2, 7, 2, 4] → [2, 7, 2, 4, 6] → [2, 7, 2, 4, 6, 5] → … 
    
    → …
    
    → [4, 6, 5, 1]
    
3. 가장 적은 횟수를 찾는다.(어차피 이동 한 번에 횟수도 1이므로 반복문을 진행한 만큼 세어주면 된다)
- 처음에 이런 식으로 생각했다가 테스트케이스 몇 개만 통과했다.. queue1에서 빼서 queue2로 간 숫자가 다시 queue1으로 들어가는 경우 또는 queue2에서 추가한 숫자가 queue1에서 빠지는 경우를 생각하지 못했다.
    
    위의 경우를 추가하려고 했다가 개같이 멸망…
    
    ```java
    for (int i = -1; i < leng * 2; i++) {
            if (i != -1) {
                s1 -= queue1[i];
            }
            long total = s1;
    
            for (int j = -1; j < leng * 2; j++) {
                if (j != -1) {
                    total += queue2[j];
                }
    
                if (total == sum && i + j < min) {
                    min = i + j + 2;
                }
                System.out.println(i + " " + j + " total " + total);
            }
        }
    ```
    
- 새로운 방식으로 조합(중복X)처럼 queue의 원소들을 item이라고 생각하고 length를 정해서 구하면 되지 않을까 하고 생각해봤는데 모든 경우를 생각할 수 있는 건 맞지만 몇 회 이동했는지 알 수가 없어서 좀 더 고민했다.
    
    그냥 선택한 연속 원소들을 남겨놓는 방식으로 하면 횟수를 구할 수 있을 것 같아서 재시도
    
1. 를 했더니 절반정도 시간초과..ㅋㅋ
2. 게다가 삼중for문을 써야 한다..
    
    ```java
    int min = qSize * 4 + 1;
            for (int leng = 1; leng <= qSize * 2; leng++) {
                // 길이별(1~queue)로 연속한 숫자를 선택
                for (int start = 0; start <= (qSize * 2 - leng - 1); start++) {
                    long total = 0;
                    for (int j = start; j < start + leng; j++) {    // 합계 계산
                        if (j < qSize) {
                            total += queue1[j];
                        } else {
                            total += queue2[j - qSize];
                        }
                    }
                    // System.out.println(leng + " " + start + " " + (start + leng - 1));
                    
                    if (total == sum) { // 이동 횟수 계산
                        int count = 0;
                        if (start + leng != qSize * 2) {
                            count += start;
                        }
                        if (start + leng > qSize) {    // 마지막 숫자가 queue2면
                            count += (start + leng) - qSize;
                        }
                        if (count < min) {
                            min = count;
                        }
                    }
                }
            }
    ```